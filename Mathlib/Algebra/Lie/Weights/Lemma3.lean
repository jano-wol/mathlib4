/-
This file defines the forward direction of the order isomorphism between Lie ideals
of a Killing Lie algebra and invariant root submodules of the associated root system.

The main construction is `lieIdealToInvtRootSubmodule`, which maps a Lie ideal `I` to
the submodule of `Dual K H` spanned by the roots whose root spaces lie in `I`.

The full order isomorphism `lieIdealOrderIso` is sketched with sorry'd proofs.
-/

import Mathlib.Algebra.Lie.Weights.IsSimple

namespace LieAlgebra.IsKilling

open LieAlgebra LieModule Module

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L] [FiniteDimensional K L]
  {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsKilling K L] [IsTriangularizable K H L]

noncomputable section

/-! ### Lie ideal decomposition (sorry'd; proved in Lemma1) -/

/-- A Lie ideal decomposes as its intersection with the Cartan subalgebra plus a direct sum of
root spaces corresponding to some subset Φ of roots. -/
lemma exists_rootSet_lieIdeal_eq (I : LieIdeal K L) :
    ∃ Φ : Set H.root, I.toSubmodule = (I.toSubmodule ⊓ H.toSubmodule) ⊔
      ⨆ α ∈ Φ, (rootSpace H α.1).toSubmodule := sorry

/-! ### Root set of a Lie ideal -/

/-- The set of roots whose root space is contained in a given Lie ideal. -/
def lieIdealRootSet (I : LieIdeal K L) : Set H.root :=
  { α | (rootSpace H α.1).toSubmodule ≤ I.toSubmodule }

/-! ### Forward map: Lie ideal → invariant root submodule -/

/-- The submodule of `Dual K H` spanned by the roots associated to a Lie ideal.
This maps each root `α ∈ Φ_I` (where `g_α ⊆ I`) to its weight functional `α : H →ₗ[K] K`,
and takes their span. -/
def lieIdealToSubmodule (I : LieIdeal K L) : Submodule K (Dual K H) :=
  Submodule.span K ((↑) '' lieIdealRootSet (H := H) I)

/-- The root set of a Lie ideal is closed under Weyl reflections: if `g_α ⊆ I` and `β` is any
root, then `g_{s_β(α)} ⊆ I`. This uses the sl₂ representation theory and the fact that
`g_{s_β(α)}` is reachable from `g_α` by iterated bracketing with `g_β` and `g_{-β}`. -/
lemma lieIdealRootSet_reflectionPerm_invariant (I : LieIdeal K L) (i : H.root)
    {α : H.root} (hα : α ∈ lieIdealRootSet (H := H) I) :
    (rootSystem H).reflectionPerm i α ∈ lieIdealRootSet (H := H) I := sorry

/-- The submodule spanned by roots of a Lie ideal is invariant under all root reflections. -/
lemma lieIdealToSubmodule_mem_invtRootSubmodule (I : LieIdeal K L) :
    lieIdealToSubmodule (H := H) I ∈ (rootSystem H).invtRootSubmodule := by
  rw [RootPairing.mem_invtRootSubmodule_iff]
  intro i
  rw [Module.End.mem_invtSubmodule]
  intro x hx
  -- x ∈ lieIdealToSubmodule I, need (rootSystem H).reflection i x ∈ lieIdealToSubmodule I
  -- Since reflection is linear and the span is generated by roots in Φ_I,
  -- it suffices to show reflection maps each generator into the span.
  -- This follows from lieIdealRootSet_reflectionPerm_invariant.
  sorry

/-- Maps a Lie ideal to its corresponding invariant root submodule. -/
def lieIdealToInvtRootSubmodule (I : LieIdeal K L) :
    (rootSystem H).invtRootSubmodule :=
  ⟨lieIdealToSubmodule (H := H) I, lieIdealToSubmodule_mem_invtRootSubmodule I⟩

/-! ### Monotonicity -/

/-- The forward map is monotone: if `I ≤ J` then the root set of `I` is contained in that of `J`,
hence the spanned submodule is smaller. -/
lemma lieIdealToInvtRootSubmodule_mono {I J : LieIdeal K L} (h : I ≤ J) :
    lieIdealToInvtRootSubmodule (H := H) I ≤ lieIdealToInvtRootSubmodule J := by
  apply Submodule.span_mono
  apply Set.image_mono
  intro α (hα : (rootSpace H α.1).toSubmodule ≤ I.toSubmodule)
  exact hα.trans h

/-! ### Order isomorphism (skeleton) -/

/-- The Cartan part `I ∩ H` is determined by the root set: it equals the span of the coroots
corresponding to roots in `Φ_I`. This is the key fact that makes the forward map injective. -/
lemma lieIdeal_inf_cartan_eq_coroot_span (I : LieIdeal K L) :
    I.toSubmodule ⊓ H.toSubmodule =
      ⨆ α ∈ lieIdealRootSet (H := H) I, (corootSubmodule α.1).toSubmodule := sorry

/-- The lattice of Lie ideals of a Killing Lie algebra is order-isomorphic to the lattice of
invariant root submodules of the associated root system. -/
def lieIdealOrderIso :
    LieIdeal K L ≃o (rootSystem H).invtRootSubmodule where
  toFun := lieIdealToInvtRootSubmodule
  invFun q := invtSubmoduleToLieIdeal q.1
    ((rootSystem H).mem_invtRootSubmodule_iff.mp q.2)
  left_inv := sorry
  right_inv := sorry
  map_rel_iff' := sorry

end

end LieAlgebra.IsKilling
