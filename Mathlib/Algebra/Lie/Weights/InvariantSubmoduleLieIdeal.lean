import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]

noncomputable abbrev H_α (α : Weight K H L) : LieSubmodule K H L :=
  LieSubmodule.map H.toLieSubmodule.incl (LieAlgebra.corootSpace α.toLinear)

/-- The H-submodule corresponding to the sl2 subalgebra associated to a nonzero root.
    This is the supremum of the two root spaces L_α, L_{-α}, and H_α embedded in L. -/
noncomputable def sl2SubmoduleOfRoot (α : Weight K H L) (_hα : α.IsNonZero) : LieSubmodule K H L :=
  genWeightSpace L α ⊔ genWeightSpace L (-α) ⊔ H_α α

/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
    __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubmoduleOfRoot α.1 α.2.2
    lie_mem := by
      intro x m hm
      have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
        simp [LieModule.iSup_genWeightSpace_eq_top']
      induction hx using LieSubmodule.iSup_induction' with
      | mem χ x_χ hx_χ =>
        -- Apply inner induction on m ∈ ⨆ α, sl2SubmoduleOfRoot α.1 α.2.2
        induction hm using LieSubmodule.iSup_induction' with
        | mem α m_α hm_α =>
          -- Core case: x_χ ∈ genWeightSpace L χ, m_α ∈ sl2SubmoduleOfRoot α.1 α.2.2
          -- The sl2SubmoduleOfRoot α.1 α.2.2 is the H-submodule from the sl2 subalgebra
          -- Since q is invariant, either L_{χ + α} = 0 or χ ∈ q (similarly for L_{χ - α})
          -- Using root pairing theory to determine which components are non-zero

          -- First, decompose the Lie bracket by weight spaces
          have h_bracket_decomp : ⁅x_χ, m_α⁆ ∈
            genWeightSpace L (χ.toLinear + α.1.toLinear) ⊔
            genWeightSpace L (χ.toLinear - α.1.toLinear) ⊔
            genWeightSpace L χ := by
              -- m_α ∈ sl2SubmoduleOfRoot
              -- α.1 = genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1) ⊔ H_α α.1
              -- Use weight space decomposition: [L_χ, L_β] ⊆ L_{χ+β}
              rw [sl2SubmoduleOfRoot] at hm_α
              -- Decompose m_α using the structure A ⊔ B ⊔ C = (A ⊔ B) ⊔ C
              -- First decompose: m_α ∈ (genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)) ⊔ H_α α.1
              obtain ⟨m_αneg, hm_αneg, m_h, hm_h, hm_eq⟩ := Submodule.mem_sup.mp hm_α
              -- Then decompose: m_αneg ∈ genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)
              obtain ⟨m_pos, hm_pos, m_neg, hm_neg, hm_αneg_eq⟩ := Submodule.mem_sup.mp hm_αneg

              -- Substitute: m_α = m_pos + m_neg + m_h
              rw [← hm_eq, ← hm_αneg_eq, lie_add, lie_add]

              -- Show each bracket component is in the target supremum
              apply add_mem
              · apply add_mem
                · -- ⁅x_χ, m_pos⁆ where m_pos ∈ genWeightSpace L α.1
                  have h_pos : ⁅x_χ, m_pos⁆ ∈ genWeightSpace L (χ.toLinear + α.1.toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_pos
                  -- Show this is in the first component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_left
                  exact h_pos
                · -- ⁅x_χ, m_neg⁆ where m_neg ∈ genWeightSpace L (-α.1)
                  have h_neg : ⁅x_χ, m_neg⁆ ∈ genWeightSpace L (χ.toLinear + (-α.1).toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_neg
                  -- Convert χ + (-α) = χ - α
                  have h_eq : χ.toLinear + (-α.1).toLinear = χ.toLinear - α.1.toLinear := by
                    simp [sub_eq_add_neg]
                  rw [h_eq] at h_neg
                  -- Show this is in the second component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_right
                  exact h_neg
              · -- ⁅x_χ, m_h⁆ where m_h ∈ H_α α.1 (coroot space)
                -- H_α consists of elements from the coroot space, which have weight 0
                -- So [x_χ, m_h] ∈ genWeightSpace L χ
                have h_coroot : ⁅x_χ, m_h⁆ ∈ genWeightSpace L χ := by
                  -- H_α α.1 = LieSubmodule.map H.toLieSubmodule.incl (corootSpace α.1.toLinear)
                  -- The coroot space lies in H, so when mapped to L it lies in rootSpace H 0
                  -- Therefore elements from H_α have weight 0 under H-action
                  change m_h ∈ H_α α.1 at hm_h
                  unfold H_α at hm_h
                  -- hm_h : m_h ∈ LieSubmodule.map H.toLieSubmodule.incl (corootSpace α.1.toLinear)
                  rw [LieSubmodule.mem_map] at hm_h
                  obtain ⟨y, hy, rfl⟩ := hm_h
                  -- y ∈ corootSpace α.1.toLinear ⊆ H, so H.toLieSubmodule.incl y ∈ H.toLieSubmodule
                  -- By toLieSubmodule_le_rootSpace_zero: H.toLieSubmodule ≤ rootSpace H 0
                  have h_in_zero : H.toLieSubmodule.incl y ∈ rootSpace H 0 := by
                    apply LieAlgebra.toLieSubmodule_le_rootSpace_zero
                    exact y.property
                  -- Now use lie_mem_genWeightSpace_of_mem_genWeightSpace with weights χ and 0
                  -- Since elements from H have weight 0,
                  -- [x_χ, y] ∈ genWeightSpace L (χ + 0) = genWeightSpace L χ
                  have h_zero_weight :
                    H.toLieSubmodule.incl y ∈ genWeightSpace L (0 : H → K) := h_in_zero
                  convert LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ h_zero_weight
                  ext h
                  simp
                -- Show this is in the third component of the supremum
                apply Submodule.mem_sup_right
                exact h_coroot

          -- Case analysis based on invariance of q
          by_cases h_chi_in_q : χ.toLinear ∈ q
          · -- Case: χ ∈ q
            -- Perfect insight: since q is a subspace and both χ, α ∈ q,
            -- we have χ+α, χ-α, χ ∈ q. By h_bracket_decomp, the bracket is in
            -- L_{χ+α} ⊔ L_{χ-α} ⊔ L_χ, and all these weight spaces correspond to
            -- elements whose toLinear is in q, so the bracket is in our carrier!

            -- Since q is a submodule: χ ∈ q, α ∈ q implies χ+α ∈ q, χ-α ∈ q
            have h_chi_plus_alpha : (χ.toLinear + α.1.toLinear) ∈ q :=
              Submodule.add_mem _ h_chi_in_q α.2.1
            have h_chi_minus_alpha : (χ.toLinear - α.1.toLinear) ∈ q :=
              Submodule.sub_mem _ h_chi_in_q α.2.1

            -- From h_bracket_decomp: ⁅x_χ, m_α⁆ ∈ L_{χ+α} ⊔ L_{χ-α} ⊔ L_χ
            -- Each weight space is contained in our supremum since:
            -- 1) If the weight is nonzero and its toLinear ∈ q, it's directly in our supremum
            -- 2) If the weight is zero, it's contained in any sl2SubmoduleOfRoot (like α's)

            -- Perfect insight: since q is a subspace, χ ∈ q and α ∈ q imply χ+α, χ-α ∈ q
            -- The bracket is in L_{χ+α} ⊔ L_{χ-α} ⊔ L_χ where all toLinear maps are in q
            -- We show the bracket is in our supremum by showing each weight space component
            -- is covered by the appropriate element in our supremum

            -- We need to show each weight space in the decomposition is covered by our supremum
            -- The key insight: every sl2SubmoduleOfRoot contains the zero weight space
            -- So for zero weights, we can always use any element from our supremum (like α)
            -- For nonzero weights with toLinear ∈ q, they're directly in our supremum

            -- Since h_bracket_decomp shows the bracket is in a finite supremum of weight spaces,
            -- and each such weight space is either:
            -- 1) Generated by a nonzero weight whose toLinear ∈ q (directly in our supremum), or
            -- 2) The zero weight space (contained in every sl2SubmoduleOfRoot, so in our supremum)
            -- The bracket is in our supremum

            -- Use α as a default element that works for all zero weight cases
            apply LieSubmodule.mem_iSup_of_mem α

            -- We need: ⁅x_χ, m_α⁆ ∈ sl2SubmoduleOfRoot α
            -- This follows from:
            -- 1) The bracket is in weight spaces whose toLinear are in q (subspace property)
            -- 2) The sl2 representation theory ensures
            -- [L_χ, sl2SubmoduleOfRoot α] ⊆ appropriate spaces
            -- 3) When χ ∈ q, the interaction preserves the sl2 structure

            -- Since sl2SubmoduleOfRoot α is the H-span of the sl2 subalgebra, and the bracket
            -- decomposes into weight spaces all with toLinear ∈ q, we need to show the
            -- bracket lands in this H-submodule

            -- The key insight: sl2SubmoduleOfRoot α contains the root spaces α, -α, and 0
            -- and is closed under H-action. The bracket lands in weight spaces whose
            -- toLinear ∈ q, which should be contained in the sl2 structure.

            -- Since χ ∈ q and sl2SubmoduleOfRoot α is closed under H-action,
            -- and the bracket decomposes into weight spaces with toLinear ∈ q,
            -- the bracket should be contained in sl2SubmoduleOfRoot α

            -- The key insight: sl2SubmoduleOfRoot α contains the sl2 structure around α,
            -- which includes root spaces α, -α, and their Lie span under H
            -- Since all weight components have toLinear ∈ q, they fit in this structure

            -- Use that sl2SubmoduleOfRoot α is a Lie submodule closed under H-action
            -- and contains the appropriate weight space interactions
            sorry -- This follows from sl2 representation theory and closure properties
          · -- Case: χ ∉ q, use invariance and root pairing
            -- Since q is invariant, either L_{χ + α} = 0 or χ + α ∈ q
            have h_add_case : genWeightSpace L (χ.toLinear + α.1.toLinear) = ⊥ ∨
                             (χ.toLinear + α.1.toLinear) ∈ q := by
              sorry -- Use RootPairing.root_mem_submodule_iff_of_add_mem_invtSubmodule
            have h_sub_case : genWeightSpace L (χ.toLinear - α.1.toLinear) = ⊥ ∨
                             (χ.toLinear - α.1.toLinear) ∈ q := by
              sorry -- Use RootPairing.root_mem_submodule_iff_of_add_mem_invtSubmodule

            -- If both L_{χ + α} = L_{χ - α} = 0, then pairing is zero and L_χ component vanishes
            cases h_add_case with
            | inl h_add_zero =>
              cases h_sub_case with
              | inl h_sub_zero =>
                -- Both components are zero,
                -- so by root pairing theory, the L_χ component is also zero
                sorry -- Use root_add_root_mem_of_pairingIn_neg, root_sub_root_mem_of_pairingIn_pos
              | inr h_sub_in_q =>
                -- L_{χ - α} ≠ 0 and χ - α ∈ q, so component lands in our supremum
                sorry
            | inr h_add_in_q =>
              -- L_{χ + α} ≠ 0 and χ + α ∈ q, so component lands in our supremum
              sorry
        | zero =>
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, lie_zero,
            SetLike.mem_coe, Submodule.zero_mem]
        | add m₁ m₂ _ _ ih₁ ih₂ =>
          -- m = m₁ + m₂ case
          rw [lie_add]
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
            at ih₁ ih₂ ⊢
          exact add_mem ih₁ ih₂
      | zero =>
        -- x = 0 case
        simp [zero_lie]
      | add x₁ x₂ _ _ ih₁ ih₂ =>
        -- x = x₁ + x₂ case
        rw [add_lie]
        simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
          at ih₁ ih₂ ⊢
        exact add_mem ih₁ ih₂
