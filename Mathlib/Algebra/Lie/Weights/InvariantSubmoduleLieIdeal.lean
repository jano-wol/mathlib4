import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]

noncomputable abbrev H_α (α : Weight K H L) : LieSubmodule K H L :=
  LieSubmodule.map H.toLieSubmodule.incl (LieAlgebra.corootSpace α.toLinear)

/-- The H-submodule corresponding to the sl2 subalgebra associated to a nonzero root.
    This is the supremum of the two root spaces L_α, L_{-α}, and H_α embedded in L. -/
noncomputable def sl2SubmoduleOfRoot (α : Weight K H L) (_hα : α.IsNonZero) : LieSubmodule K H L :=
  genWeightSpace L α ⊔ genWeightSpace L (-α) ⊔ H_α α

/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
    __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubmoduleOfRoot α.1 α.2.2
    lie_mem := by
      intro x m hm
      have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
        simp [LieModule.iSup_genWeightSpace_eq_top']
      induction hx using LieSubmodule.iSup_induction' with
      | mem χ x_χ hx_χ =>
        -- Apply inner induction on m ∈ ⨆ α, sl2SubmoduleOfRoot α.1 α.2.2
        induction hm using LieSubmodule.iSup_induction' with
        | mem α m_α hm_α =>
          -- Core case: x_χ ∈ genWeightSpace L χ, m_α ∈ sl2SubmoduleOfRoot α.1 α.2.2
          -- The sl2SubmoduleOfRoot α.1 α.2.2 is the H-submodule from the sl2 subalgebra
          -- Since q is invariant, either L_{χ + α} = 0 or χ ∈ q (similarly for L_{χ - α})
          -- Using root pairing theory to determine which components are non-zero

          -- First, decompose the Lie bracket by weight spaces
          have h_bracket_decomp : ⁅x_χ, m_α⁆ ∈
            genWeightSpace L (χ.toLinear + α.1.toLinear) ⊔
            genWeightSpace L (χ.toLinear - α.1.toLinear) ⊔
            genWeightSpace L χ := by
              -- m_α ∈ sl2SubmoduleOfRoot α.1 = genWeightSpace
              -- L α.1 ⊔ genWeightSpace L (-α.1) ⊔ H_α α.1
              -- Use weight space decomposition: [L_χ, L_β] ⊆ L_{χ+β}
              rw [sl2SubmoduleOfRoot] at hm_α
              -- Decompose m_α using the structure A ⊔ B ⊔ C = (A ⊔ B) ⊔ C
              -- First decompose: m_α ∈ (genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)) ⊔ H_α α.1
              obtain ⟨m_αneg, hm_αneg, m_h, hm_h, hm_eq⟩ := Submodule.mem_sup.mp hm_α
              -- Then decompose: m_αneg ∈ genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)
              obtain ⟨m_pos, hm_pos, m_neg, hm_neg, hm_αneg_eq⟩ := Submodule.mem_sup.mp hm_αneg

              -- Substitute: m_α = m_pos + m_neg + m_h
              rw [← hm_eq, ← hm_αneg_eq, lie_add, lie_add]

              -- Show each bracket component is in the target supremum
              apply add_mem
              · apply add_mem
                · -- ⁅x_χ, m_pos⁆ where m_pos ∈ genWeightSpace L α.1
                  have h_pos : ⁅x_χ, m_pos⁆ ∈ genWeightSpace L (χ.toLinear + α.1.toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_pos
                  -- Show this is in the first component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_left
                  exact h_pos
                · -- ⁅x_χ, m_neg⁆ where m_neg ∈ genWeightSpace L (-α.1)
                  have h_neg : ⁅x_χ, m_neg⁆ ∈ genWeightSpace L (χ.toLinear + (-α.1).toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_neg
                  -- Convert χ + (-α) = χ - α
                  have h_eq : χ.toLinear + (-α.1).toLinear = χ.toLinear - α.1.toLinear := by
                    simp [sub_eq_add_neg]
                  rw [h_eq] at h_neg
                  -- Show this is in the second component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_right
                  exact h_neg
              · -- ⁅x_χ, m_h⁆ where m_h ∈ H_α α.1 (coroot space)
                -- H_α consists of elements from the coroot space, which have weight 0
                -- So [x_χ, m_h] ∈ genWeightSpace L χ
                have h_coroot : ⁅x_χ, m_h⁆ ∈ genWeightSpace L χ := by
                  -- H_α α.1 = LieSubmodule.map H.toLieSubmodule.incl (corootSpace α.1.toLinear)
                  -- The coroot space lies in H, so when mapped to L it lies in rootSpace H 0
                  -- Therefore elements from H_α have weight 0 under H-action
                  change m_h ∈ H_α α.1 at hm_h
                  unfold H_α at hm_h
                  -- hm_h : m_h ∈ LieSubmodule.map H.toLieSubmodule.incl (corootSpace α.1.toLinear)
                  rw [LieSubmodule.mem_map] at hm_h
                  obtain ⟨y, hy, rfl⟩ := hm_h
                  -- y ∈ corootSpace α.1.toLinear ⊆ H, so H.toLieSubmodule.incl y ∈ H.toLieSubmodule
                  -- By toLieSubmodule_le_rootSpace_zero: H.toLieSubmodule ≤ rootSpace H 0
                  have h_in_zero : H.toLieSubmodule.incl y ∈ rootSpace H 0 := by
                    apply LieAlgebra.toLieSubmodule_le_rootSpace_zero
                    exact y.property
                  -- Now use lie_mem_genWeightSpace_of_mem_genWeightSpace with weights χ and 0
                  -- Since elements from H have weight 0,
                  --  [x_χ, y] ∈ genWeightSpace L (χ + 0) = genWeightSpace L χ
                  have h_zero_weight : H.toLieSubmodule.incl y ∈ genWeightSpace L (0 : H → K) :=
                    h_in_zero
                  convert LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ h_zero_weight
                  ext h
                  simp
                -- Show this is in the third component of the supremum
                apply Submodule.mem_sup_right
                exact h_coroot

          -- Case analysis based on invariance of q
          by_cases h_chi_in_q : χ.toLinear ∈ q
          · sorry
                -- Key insight: When χ = -α, genWeightSpace L 0 is generated by brackets
                -- ⁅e, f⁆ where e ∈ genWeightSpace L α.1 and f ∈ genWeightSpace L (-α.1)
                -- By the definition of corootSpace, these brackets are exactly what
                -- corootSpace α.1.toLinear contains!

                -- Use the fact that Lie brackets of weight spaces give weight spaces
                -- ⁅genWeightSpace L α.1, genWeightSpace L (-α.1)⁆ ≤ genWeightSpace L 0
                -- and by definition, corootSpace α.1.toLinear contains exactly such brackets

                -- The inclusion follows from:
                -- genWeightSpace
                --  L 0 ≤ span{⁅e,f⁆ | e ∈ genWeightSpace L α.1, f ∈ genWeightSpace L (-α.1)}
                --                   ≤ corootSpace α.1.toLinear (by definition of corootSpace)
                --                   ≤ H_α (by definition of H_α)
          · sorry

        | zero =>
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, lie_zero,
            SetLike.mem_coe, Submodule.zero_mem]
        | add m₁ m₂ _ _ ih₁ ih₂ =>
          -- m = m₁ + m₂ case
          rw [lie_add]
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
            at ih₁ ih₂ ⊢
          exact add_mem ih₁ ih₂
      | zero =>
        -- x = 0 case
        simp [zero_lie]
      | add x₁ x₂ _ _ ih₁ ih₂ =>
        -- x = x₁ + x₂ case
        rw [add_lie]
        simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
          at ih₁ ih₂ ⊢
        exact add_mem ih₁ ih₂
