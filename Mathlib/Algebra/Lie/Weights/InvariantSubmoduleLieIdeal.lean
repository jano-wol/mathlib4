import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]

/-- The H-submodule generated by the three root spaces of an sl2 subalgebra -/
noncomputable def sl2SubmoduleOfRoot (α : Weight K H L) : LieSubmodule K H L :=
  rootSpace H α ⊔ rootSpace H (-α) ⊔ rootSpace H 0

/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
    __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubmoduleOfRoot α.1
    lie_mem := by
      intro x m hm
      have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
        simp [LieModule.iSup_genWeightSpace_eq_top']
      induction hx using LieSubmodule.iSup_induction' with
      | mem χ x_χ hx_χ =>
        -- Apply inner induction on m ∈ ⨆ α, sl2SubmoduleOfRoot α.1
        induction hm using LieSubmodule.iSup_induction' with
        | mem α m_α hm_α =>
          -- Core case: x_χ ∈ genWeightSpace L χ, m_α ∈ sl2SubmoduleOfRoot α.1
          -- By definition of sl2SubmoduleOfRoot, [x_χ, m_α] ∈ L_{χ + α} ⊕ L_{χ - α} ⊕ L_χ
          -- Since q is invariant, either L_{χ + α} = 0 or χ ∈ q (similarly for L_{χ - α})
          -- Using root pairing theory to determine which components are non-zero

          -- First, decompose the Lie bracket by weight spaces
          have h_bracket_decomp : ⁅x_χ, m_α⁆ ∈
            genWeightSpace L (χ.toLinear + α.1.toLinear) ⊔
            genWeightSpace L (χ.toLinear - α.1.toLinear) ⊔
            genWeightSpace L χ := by
              -- m_α ∈ sl2SubmoduleOfRoot α.1 = rootSpace H α ⊔ rootSpace H (-α) ⊔ rootSpace H 0
              -- Use weight space decomposition: [L_χ, L_β] ⊆ L_{χ+β}
              rw [sl2SubmoduleOfRoot] at hm_α
              simp only [rootSpace] at hm_α
              -- Decompose m_α using the structure A ⊔ B ⊔ C = (A ⊔ B) ⊔ C
              -- First decompose: m_α ∈ (genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)) ⊔
              --  genWeightSpace L 0
              obtain ⟨m_αneg, hm_αneg, m_zero, hm_zero, hm_eq⟩ := Submodule.mem_sup.mp hm_α
              -- Then decompose: m_αneg ∈ genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)
              obtain ⟨m_pos, hm_pos, m_neg, hm_neg, hm_αneg_eq⟩ := Submodule.mem_sup.mp hm_αneg

              -- Substitute: m_α = m_pos + m_neg + m_zero
              rw [← hm_eq, ← hm_αneg_eq, lie_add, lie_add]

              -- Show each bracket component is in the target supremum
              apply add_mem
              · apply add_mem
                · -- ⁅x_χ, m_pos⁆ where m_pos ∈ genWeightSpace L α.1
                  have h_pos : ⁅x_χ, m_pos⁆ ∈ genWeightSpace L (χ.toLinear + α.1.toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_pos
                  -- Show this is in the first component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_left
                  exact h_pos
                · -- ⁅x_χ, m_neg⁆ where m_neg ∈ genWeightSpace L (-α.1)
                  have h_neg : ⁅x_χ, m_neg⁆ ∈ genWeightSpace L (χ.toLinear + (-α.1).toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_neg
                  -- Convert χ + (-α) = χ - α
                  have h_eq : χ.toLinear + (-α.1).toLinear = χ.toLinear - α.1.toLinear := by
                    simp [sub_eq_add_neg]
                  rw [h_eq] at h_neg
                  -- Show this is in the second component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_right
                  exact h_neg
              · -- ⁅x_χ, m_zero⁆ where m_zero ∈ genWeightSpace L 0
                have h_zero : ⁅x_χ, m_zero⁆ ∈ genWeightSpace L (χ.toLinear + (0 : H →ₗ[K] K)) := by
                  exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_zero
                rw [add_zero] at h_zero
                -- Show this is in the third component of the supremum
                apply Submodule.mem_sup_right
                exact h_zero

          -- Case analysis based on invariance of q
          by_cases h_chi_in_q : χ.toLinear ∈ q
          · -- Case: χ ∈ q, so L_χ ⊆ ⨆ α ∈ q, sl2SubmoduleOfRoot α
            sorry -- Use that χ ∈ q implies the result is in our supremum
          · -- Case: χ ∉ q, use invariance and root pairing
            -- Since q is invariant, either L_{χ + α} = 0 or χ + α ∈ q
            have h_add_case : genWeightSpace L (χ.toLinear + α.1.toLinear) = ⊥ ∨
                             (χ.toLinear + α.1.toLinear) ∈ q := by
              sorry -- Use RootPairing.root_mem_submodule_iff_of_add_mem_invtSubmodule
            have h_sub_case : genWeightSpace L (χ.toLinear - α.1.toLinear) = ⊥ ∨
                             (χ.toLinear - α.1.toLinear) ∈ q := by
              sorry -- Use RootPairing.root_mem_submodule_iff_of_add_mem_invtSubmodule

            -- If both L_{χ + α} = L_{χ - α} = 0, then pairing is zero and L_χ component vanishes
            cases h_add_case with
            | inl h_add_zero =>
              cases h_sub_case with
              | inl h_sub_zero =>
                -- Both components are zero,
                -- so by root pairing theory, the L_χ component is also zero
                sorry -- Use root_add_root_mem_of_pairingIn_neg, root_sub_root_mem_of_pairingIn_pos
              | inr h_sub_in_q =>
                -- L_{χ - α} ≠ 0 and χ - α ∈ q, so component lands in our supremum
                sorry
            | inr h_add_in_q =>
              -- L_{χ + α} ≠ 0 and χ + α ∈ q, so component lands in our supremum
              sorry
        | zero =>
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, lie_zero,
            SetLike.mem_coe, Submodule.zero_mem]
        | add m₁ m₂ _ _ ih₁ ih₂ =>
          -- m = m₁ + m₂ case
          rw [lie_add]
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
            at ih₁ ih₂ ⊢
          exact add_mem ih₁ ih₂
      | zero =>
        -- x = 0 case
        simp [zero_lie]
      | add x₁ x₂ _ _ ih₁ ih₂ =>
        -- x = x₁ + x₂ case
        rw [add_lie]
        simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
          at ih₁ ih₂ ⊢
        exact add_mem ih₁ ih₂
