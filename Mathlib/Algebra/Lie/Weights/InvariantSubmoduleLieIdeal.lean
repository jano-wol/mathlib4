import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]

noncomputable abbrev H_α (α : Weight K H L) : LieSubmodule K H L :=
  LieSubmodule.map H.toLieSubmodule.incl (LieAlgebra.corootSpace α.toLinear)


/-- The sl2SubalgebraOfRoot is stable under H-action, so it can be viewed as an H-submodule -/
lemma sl2SubalgebraOfRoot_stable_under_H (α : Weight K H L) (hα : α.IsNonZero) :
    ∀ (h : H) (x : L), x ∈ sl2SubalgebraOfRoot hα → ⁅(h : L), x⁆ ∈ sl2SubalgebraOfRoot hα := by
  intro h x hx
  -- Since sl2SubalgebraOfRoot is generated by weight spaces,
  -- and H acts on weight spaces by scaling,
  -- the bracket ⁅h, x⁆ stays in the same weight spaces
  obtain ⟨h', e, f, ht, heα, hfα⟩ := LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero hα
  rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα] at hx ⊢
  obtain ⟨c₁, c₂, c₃, hx_eq⟩ := hx
  -- x = c₁ • e + c₂ • f + c₃ • ⁅e, f⁆
  rw [hx_eq, lie_add, lie_add, lie_smul, lie_smul, lie_smul]
  -- Use the fact that H acts by scaling on weight spaces
  have he_weight : ⁅(h : L), e⁆ = α h • e := by
    exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace heα h
  have hf_weight : ⁅(h : L), f⁆ = (-α) h • f := by
    exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace hfα h
  have hef_weight : ⁅(h : L), ⁅e, f⁆⁆ = 0 • ⁅e, f⁆ := by
    -- ⁅e, f⁆ is the coroot, which lies in H
    -- Since H is abelian (Cartan subalgebras are abelian), ⁅h, ⁅e, f⁆⁆ = 0
    have h_coroot : ⁅e, f⁆ = (LieAlgebra.IsKilling.coroot α : L) := by
      have : ⁅e, f⁆ = h' := ht.lie_e_f
      rw [this]
      exact IsSl2Triple.h_eq_coroot hα ht heα hfα
    rw [h_coroot]
    -- coroot α ∈ H, and since H is abelian, ⁅h, coroot α⁆ = 0
    have : ⁅(h : L), (LieAlgebra.IsKilling.coroot α : L)⁆ = 0 := by
      -- The coroot has weight 0 (it lies in H, the zero weight space)
      -- By lie_eq_smul_of_mem_rootSpace: ⁅h, x⁆ = weight(x) h • x
      -- Since coroot α ∈ H has weight 0, we get ⁅h, coroot α⁆ = 0 • coroot α = 0
      have h_coroot_in_H : (LieAlgebra.IsKilling.coroot α : L) ∈ rootSpace H (0 : H → K) := by
        -- coroot α ∈ H and rootSpace H 0 = H.toLieSubmodule
        have h_coroot_mem_H : (LieAlgebra.IsKilling.coroot α : L) ∈ H := by
          exact (LieAlgebra.IsKilling.coroot α).property
        have h_eq : rootSpace H (0 : H → K) = H.toLieSubmodule := rootSpace_zero_eq K L H
        rw [h_eq]
        exact h_coroot_mem_H
      -- Apply lie_eq_smul_of_mem_rootSpace with weight 0
      have h_eq : ⁅(h : L), (LieAlgebra.IsKilling.coroot α : L)⁆ =
        (0 : H → K) h • (LieAlgebra.IsKilling.coroot α : L) := by
        exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace h_coroot_in_H h
      rw [h_eq]
      simp only [Pi.zero_apply, zero_smul]
    rw [this, zero_smul]
  rw [he_weight, hf_weight, hef_weight, smul_smul, smul_smul, zero_smul]
  simp only [Weight.coe_neg, Pi.neg_apply, smul_zero, add_zero]
  exact ⟨c₁ * α h, c₂ * (-α h), 0, by simp [mul_smul]⟩

/-- The sl2SubalgebraOfRoot can be viewed as an H-submodule -/
noncomputable def sl2SubalgebraOfRoot_as_H_submodule (α : Weight K H L) (hα : α.IsNonZero) :
    LieSubmodule K H L where
  __ := (sl2SubalgebraOfRoot hα).toLieSubmodule
  lie_mem := by
    intro h x hx
    exact sl2SubalgebraOfRoot_stable_under_H α hα h x hx

/-- The sl2SubalgebraOfRoot_as_H_submodule
    has the supremum structure needed for weight space decomposition -/
lemma sl2SubalgebraOfRoot_as_H_submodule_eq_sup (α : Weight K H L) (hα : α.IsNonZero) :
    sl2SubalgebraOfRoot_as_H_submodule α hα =
    genWeightSpace L α.toLinear ⊔ genWeightSpace L (-α).toLinear ⊔ H_α α := by
  ext x
  constructor
  · -- Direction: sl2SubalgebraOfRoot_as_H_submodule → supremum
    intro hx
    -- x ∈ sl2SubalgebraOfRoot, so x = c₁ • e + c₂ • f + c₃ • ⁅e, f⁆
    simp only [sl2SubalgebraOfRoot_as_H_submodule] at hx
    obtain ⟨h', e, f, ht, heα, hfα⟩ :=
      LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero hα
    have hx_sl2 : x ∈ sl2SubalgebraOfRoot hα := hx
    rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα] at hx_sl2
    obtain ⟨c₁, c₂, c₃, hx_eq⟩ := hx_sl2
    -- Show x is in the supremum
    rw [hx_eq]
    apply add_mem
    · apply add_mem
      · apply Submodule.smul_mem
        apply Submodule.mem_sup_left
        apply Submodule.mem_sup_left
        exact heα
      · apply Submodule.smul_mem
        apply Submodule.mem_sup_left
        apply Submodule.mem_sup_right
        exact hfα
    · -- c₃ • ⁅e, f⁆ ∈ H_α α
      apply Submodule.smul_mem
      apply Submodule.mem_sup_right
      -- ⁅e, f⁆ = h' ∈ H_α α
      unfold H_α
      -- Goal is already in LieSubmodule.mem_map form after unfold
      have h_coroot_eq : ⁅e, f⁆ = h' := ht.lie_e_f
      rw [h_coroot_eq]
      -- h' is the coroot, which should be in the coroot space
      use (LieAlgebra.IsKilling.coroot α : H)
      constructor
      · -- coroot α ∈ corootSpace α.toLinear
        -- The coroot space is spanned by the coroot, so the coroot is in it
        have h_eq : (corootSpace α.toLinear).toSubmodule = K ∙ LieAlgebra.IsKilling.coroot α :=
          LieAlgebra.IsKilling.coe_corootSpace_eq_span_singleton α
        change LieAlgebra.IsKilling.coroot α ∈ (corootSpace α.toLinear : Set H)
        rw [LieSubmodule.mem_coe, ← LieSubmodule.mem_toSubmodule, h_eq]
        exact Submodule.mem_span_singleton_self _
      · -- H.toLieSubmodule.incl (coroot α) = h'
        have h_eq : h' = (LieAlgebra.IsKilling.coroot α : L) :=
          IsSl2Triple.h_eq_coroot hα ht heα hfα
        rw [h_eq]
        rfl
  · -- Direction: supremum → sl2SubalgebraOfRoot_as_H_submodule
    intro hx
    -- x ∈ genWeightSpace L α.toLinear ⊔ genWeightSpace L (-α).toLinear ⊔ H_α α
    obtain ⟨x_αneg, hx_αneg, x_h, hx_h, hx_eq⟩ := Submodule.mem_sup.mp hx
    obtain ⟨x_pos, hx_pos, x_neg, hx_neg, hx_αneg_eq⟩ := Submodule.mem_sup.mp hx_αneg
    -- Now x = x_pos + x_neg + x_h where x_pos ∈ genWeightSpace L α, etc.
    -- We need to show this is in sl2SubalgebraOfRoot
    rw [← hx_eq, ← hx_αneg_eq]
    simp only [sl2SubalgebraOfRoot_as_H_submodule]
    -- Use the fact that sl2SubalgebraOfRoot contains the weight spaces by construction
    -- The key insight: sl2SubalgebraOfRoot is generated by elements from these exact weight spaces
    obtain ⟨h', e, f, ht, heα, hfα⟩ :=
      LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero hα

    -- Each component is automatically in the sl2 subalgebra
    have hx_pos_in : x_pos ∈ sl2SubalgebraOfRoot hα := by
      -- x_pos ∈ rootSpace H α.toLinear, and this space is generated by e in the sl2 subalgebra
      rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα]
      -- Since rootSpace is 1-dimensional and generated by e, x_pos = c • e for some c
      -- Use the spanning property of sl2 subalgebras
      -- Since x_pos ∈ rootSpace H α and e ∈ rootSpace H α, and root spaces are 1-dimensional,
      -- x_pos = c₁ • e for some c₁
      have h_dim : Module.finrank K (rootSpace H α.toLinear) = 1 :=
        LieAlgebra.IsKilling.finrank_rootSpace_eq_one α hα
      have he_ne_zero : e ≠ 0 := ht.e_ne_zero
      have he_subtype_ne_zero : (⟨e, heα⟩ : rootSpace H α.toLinear) ≠ 0 := by
        rwa [ne_eq, LieSubmodule.mk_eq_zero]
      obtain ⟨c₁, hc₁⟩ :=
        (finrank_eq_one_iff_of_nonzero' ⟨e, heα⟩ he_subtype_ne_zero).mp h_dim ⟨x_pos, hx_pos⟩
      have hx_pos_eq : x_pos = c₁ • e := by
        have : x_pos = (⟨x_pos, hx_pos⟩ : rootSpace H α.toLinear).val := rfl
        rw [this, ← hc₁]; simp
      -- Therefore x_pos = c₁ • e + 0 • f + 0 • ⁅e, f⁆
      exact ⟨c₁, 0, 0, by simp [hx_pos_eq]⟩

    have hx_neg_in : x_neg ∈ sl2SubalgebraOfRoot hα := by
      -- Similar argument for the -α weight space
      rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα]
      -- Since x_neg ∈ rootSpace H (-α) and f ∈ rootSpace H (-α), and root spaces are 1-dimensional,
      -- x_neg = c₂ • f for some c₂
      have h_neg_dim : Module.finrank K (rootSpace H (-α).toLinear) = 1 :=
        LieAlgebra.IsKilling.finrank_rootSpace_eq_one (-α) (by simpa using hα)
      have hf_ne_zero : f ≠ 0 := ht.f_ne_zero
      have hf_subtype_ne_zero : (⟨f, hfα⟩ : rootSpace H (-α).toLinear) ≠ 0 := by
        rwa [ne_eq, LieSubmodule.mk_eq_zero]
      obtain ⟨c₂, hc₂⟩ :=
        (finrank_eq_one_iff_of_nonzero' ⟨f, hfα⟩ hf_subtype_ne_zero).mp h_neg_dim ⟨x_neg, hx_neg⟩
      have hx_neg_eq : x_neg = c₂ • f := by
        have : x_neg = (⟨x_neg, hx_neg⟩ : rootSpace H (-α).toLinear).val := rfl
        rw [this, ← hc₂]; simp
      -- Therefore x_neg = 0 • e + c₂ • f + 0 • ⁅e, f⁆
      exact ⟨0, c₂, 0, by simp [hx_neg_eq]⟩

    have hx_h_in : x_h ∈ sl2SubalgebraOfRoot hα := by
      -- x_h ∈ H_α α which is the coroot space, part of the sl2 subalgebra
      rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα]
      -- Since x_h ∈ H_α α = coroot space, and coroot space is spanned by ⁅e, f⁆,
      -- x_h = c₃ • ⁅e, f⁆ for some c₃ (since it's 1-dimensional)
      unfold H_α at hx_h
      -- Goal is already in the LieSubmodule.mem_map form after unfold
      obtain ⟨y, hy_coroot, hy_eq⟩ := hx_h
      -- y ∈ corootSpace α.toLinear, and this space is 1-dimensional spanned by coroot α
      -- We'll use the fact that x_h can be expressed in terms of ⁅e, f⁆
      -- For simplicity, since the spaces are 1-dimensional and contain the bracket ⁅e, f⁆,
      -- any element can be written as a scalar multiple
      -- This is a bit complex to prove rigorously, so let's use a direct approach
      -- The key insight is that H_α is exactly the image of the coroot space in L
      -- and the coroot space is spanned by the coroot which equals ⁅e, f⁆
      have h_eq : ⁅e, f⁆ = h' := ht.lie_e_f
      have h_coroot : h' = (LieAlgebra.IsKilling.coroot α : L) :=
        IsSl2Triple.h_eq_coroot hα ht heα hfα
      -- Since x_h ∈ H_α α (which is the image of the coroot space in L),
      -- and the coroot space is spanned by ⁅e, f⁆, x_h is of the form c₃ • ⁅e, f⁆
      -- We can use the fact that H_α is exactly the subspace generated by ⁅e, f⁆
      have h_ef_in_sl2 : ⁅e, f⁆ ∈ sl2SubalgebraOfRoot hα := by
        rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα]
        exact ⟨0, 0, 1, by simp⟩

      -- Since x_h ∈ H_α α and H_α α is the image of the coroot space,
      -- and the coroot space is 1-dimensional spanned by coroot α = ⁅e, f⁆,
      -- we can express x_h as a scalar multiple of ⁅e, f⁆

      -- From the context: y ∈ corootSpace α.toLinear and x_h = H.incl y
      -- Since corootSpace is spanned by coroot α, y = c₃ • coroot α for some c₃
      -- And since coroot α = ⁅e, f⁆, we get x_h = c₃ • ⁅e, f⁆

      -- The coroot space is 1-dimensional, so express y as a scalar multiple of the coroot
      have h_coroot_span : (corootSpace α.toLinear).toSubmodule =
        K ∙ (LieAlgebra.IsKilling.coroot α) :=
        LieAlgebra.IsKilling.coe_corootSpace_eq_span_singleton α

      -- Since y ∈ corootSpace and the space is spanned by the coroot, y = c₃ • coroot α
      have hy_mem_submodule : y ∈ (corootSpace α.toLinear).toSubmodule := by
        rw [LieSubmodule.mem_toSubmodule]
        exact hy_coroot

      rw [h_coroot_span] at hy_mem_submodule
      obtain ⟨c₃, hc₃⟩ := Submodule.mem_span_singleton.mp hy_mem_submodule

      -- Express x_h in terms of ⁅e, f⁆
      have hx_h_eq : x_h = c₃ • ⁅e, f⁆ := by
        -- We have y = c₃ • coroot α and x_h = H.incl y
        -- Since coroot α = ⁅e, f⁆ as elements of L, we get the result
        rw [← hy_eq, ← hc₃, map_smul]
        -- Now we need: c₃ • H.incl (coroot α) = c₃ • ⁅e, f⁆
        -- We have H.incl (coroot α) = (coroot α : L) and coroot α = h' = ⁅e, f⁆
        congr 1
        -- Goal: H.incl (coroot α) = ⁅e, f⁆
        -- This should follow from the fact that the coroot as an element of L equals h'
        -- and h' = ⁅e, f⁆, and H.incl just embeds H into L
        -- The coroot embedding should give the same element of L
        have h_embed : (LieAlgebra.IsKilling.coroot α : L) =
          H.toLieSubmodule.incl (LieAlgebra.IsKilling.coroot α) := by
          rfl -- The coercion and the inclusion should be definitionally equal
        -- Chain of equalities: H.incl(coroot α) = ↑(coroot α) = h' = ⁅e, f⁆
        exact h_embed ▸ h_coroot ▸ h_eq.symm

      -- Therefore x_h = 0 • e + 0 • f + c₃ • ⁅e, f⁆
      exact ⟨0, 0, c₃, by simp [hx_h_eq]⟩

    -- Therefore their sum is in the sl2 subalgebra
    apply add_mem (add_mem hx_pos_in hx_neg_in) hx_h_in


/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
    __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero},
      sl2SubalgebraOfRoot_as_H_submodule α.1 α.2.2
    lie_mem := by
      intro x m hm
      have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
        simp [LieModule.iSup_genWeightSpace_eq_top']
      induction hx using LieSubmodule.iSup_induction' with
      | mem χ x_χ hx_χ =>
        -- Apply inner induction on m ∈ ⨆ α, sl2SubmoduleOfRoot α.1 α.2.2
        induction hm using LieSubmodule.iSup_induction' with
        | mem α m_α hm_α =>
          -- Core case: x_χ ∈ genWeightSpace L χ, m_α ∈ sl2SubalgebraOfRoot_as_H_submodule α.1 α.2.2
          -- Since we now use sl2SubalgebraOfRoot_as_H_submodule,
          -- we have m_α ∈ sl2SubalgebraOfRoot α.2.2
          -- This greatly simplifies the proof


          -- The bracket ⁅x_χ, m_α⁆ lies in the sl2 subalgebra translated by weight χ
          -- This follows from weight space addition: [L_χ, sl2_α] ⊆ L_{χ+α} ⊔ L_{χ-α} ⊔ L_χ
          have h_bracket_decomp : ⁅x_χ, m_α⁆ ∈
            genWeightSpace L (χ.toLinear + α.1.toLinear) ⊔
            genWeightSpace L (χ.toLinear - α.1.toLinear) ⊔
            genWeightSpace L χ := by
              -- Use the proven equivalence to decompose m_α
              -- m_α ∈ sl2SubalgebraOfRoot_as_H_submodule α.1 α.2.2 =
              --       genWeightSpace L α.1.toLinear ⊔ genWeightSpace L (-α.1).toLinear ⊔ H_α α.1
              rw [sl2SubalgebraOfRoot_as_H_submodule_eq_sup] at hm_α

              -- Decompose m_α using the supremum structure
              -- First: m_α ∈ (genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)) ⊔ H_α α.1
              obtain ⟨m_αneg, hm_αneg, m_h, hm_h, hm_eq⟩ := Submodule.mem_sup.mp hm_α
              -- Then: m_αneg ∈ genWeightSpace L α.1 ⊔ genWeightSpace L (-α.1)
              obtain ⟨m_pos, hm_pos, m_neg, hm_neg, hm_αneg_eq⟩ := Submodule.mem_sup.mp hm_αneg

              -- Substitute: m_α = m_pos + m_neg + m_h
              rw [← hm_eq, ← hm_αneg_eq, lie_add, lie_add]

              -- Show each bracket component is in the target supremum
              apply add_mem
              · apply add_mem
                · -- ⁅x_χ, m_pos⁆ where m_pos ∈ genWeightSpace L α.1
                  have h_pos : ⁅x_χ, m_pos⁆ ∈ genWeightSpace L (χ.toLinear + α.1.toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_pos
                  -- Show this is in the first component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_left
                  exact h_pos
                · -- ⁅x_χ, m_neg⁆ where m_neg ∈ genWeightSpace L (-α.1)
                  have h_neg : ⁅x_χ, m_neg⁆ ∈ genWeightSpace L (χ.toLinear + (-α.1).toLinear) := by
                    exact LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ hm_neg
                  -- Convert χ + (-α) = χ - α
                  have h_eq : χ.toLinear + (-α.1).toLinear = χ.toLinear - α.1.toLinear := by
                    simp [sub_eq_add_neg]
                  rw [h_eq] at h_neg
                  -- Show this is in the second component of the supremum
                  apply Submodule.mem_sup_left
                  apply Submodule.mem_sup_right
                  exact h_neg
              · -- ⁅x_χ, m_h⁆ where m_h ∈ H_α α.1 (coroot space)
                -- H_α consists of elements from the coroot space, which have weight 0
                -- So [x_χ, m_h] ∈ genWeightSpace L χ
                have h_coroot : ⁅x_χ, m_h⁆ ∈ genWeightSpace L χ := by
                  -- H_α α consists of elements from the coroot space mapped to L
                  -- The coroot space lies in H, so these elements have weight 0 under H-action
                  -- Therefore elements from H_α have weight 0, so [x_χ, m_h] ∈
                  -- genWeightSpace L (χ + 0) = genWeightSpace L χ

                  -- hm_h : m_h ∈ LieSubmodule.map H.toLieSubmodule.incl (corootSpace α.1.toLinear)
                  obtain ⟨y, hy, rfl⟩ := hm_h
                  -- y ∈ corootSpace α.1.toLinear ⊆ H, so H.toLieSubmodule.incl y ∈ H.toLieSubmodule
                  -- By toLieSubmodule_le_rootSpace_zero: H.toLieSubmodule ≤ rootSpace H 0
                  have h_in_zero : H.toLieSubmodule.incl y ∈ rootSpace H 0 := by
                    apply LieAlgebra.toLieSubmodule_le_rootSpace_zero
                    exact y.property
                  -- Now use lie_mem_genWeightSpace_of_mem_genWeightSpace with weights χ and 0
                  -- Since elements from H have weight 0, [x_χ, y] ∈ genWeightSpace L (χ + 0) =
                  -- genWeightSpace L χ
                  have h_zero_weight : H.toLieSubmodule.incl y ∈ genWeightSpace L (0 : H → K) :=
                    h_in_zero
                  convert LieAlgebra.lie_mem_genWeightSpace_of_mem_genWeightSpace hx_χ h_zero_weight
                  ext h
                  simp
                -- Show this is in the third component of the supremum
                apply Submodule.mem_sup_right
                exact h_coroot

          -- Handle special cases first: if they occur, we can prove the goal directly
          by_cases h_plus_case : χ.toLinear + α.1.toLinear = 0
          · -- Case: χ + α = 0 (χ = -α) - we're done here
            have h_chi_neg_alpha : χ.toLinear = -α.1.toLinear := by
              simp only [add_eq_zero_iff_eq_neg] at h_plus_case; exact h_plus_case

            -- Prove the main goal directly when this special case holds
            apply LieSubmodule.mem_iSup_of_mem α
            simp only [sl2SubalgebraOfRoot_as_H_submodule]

            have hx_χ_neg_alpha : x_χ ∈ genWeightSpace L (-α.1.toLinear) := by
              rw [← h_chi_neg_alpha]; exact hx_χ

            have hx_χ_in_sl2 : x_χ ∈ sl2SubalgebraOfRoot α.2.2 := by
              have hx_χ_neg : x_χ ∈ rootSpace H (-α.1.toLinear) := hx_χ_neg_alpha
              obtain ⟨h, e, f, ht, heα, hfα⟩ :=
                LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero α.2.2
              rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff α.2.2 ht heα hfα]
              have h_dim : Module.finrank K (rootSpace H (-α.1.toLinear)) = 1 :=
                LieAlgebra.IsKilling.finrank_rootSpace_eq_one (-α.1) (by simpa using α.2.2)
              have hf_ne_zero : f ≠ 0 := ht.f_ne_zero
              have hf_subtype_ne_zero : (⟨f, hfα⟩ : rootSpace H (-α.1.toLinear)) ≠ 0 := by
                rwa [ne_eq, LieSubmodule.mk_eq_zero]
              obtain ⟨c, hc⟩ := (finrank_eq_one_iff_of_nonzero'
                ⟨f, hfα⟩ hf_subtype_ne_zero).mp h_dim ⟨x_χ, hx_χ_neg⟩
              have hc_proj : x_χ = c • f := by
                have : x_χ = (⟨x_χ, hx_χ_neg⟩ : rootSpace H (-α.1.toLinear)).val := rfl
                rw [this, ← hc]; simp
              exact ⟨0, c, 0, by simp [hc_proj]⟩

            have h_bracket_in_sl2 : ⁅x_χ, m_α⁆ ∈ sl2SubalgebraOfRoot α.2.2 := by
              have hm_α_in_sl2 : m_α ∈ sl2SubalgebraOfRoot α.2.2 := by
                simp only [sl2SubalgebraOfRoot_as_H_submodule] at hm_α; exact hm_α
              apply LieSubalgebra.lie_mem; exact hx_χ_in_sl2; exact hm_α_in_sl2
            exact h_bracket_in_sl2
          · -- Case: χ + α ≠ 0, now we have h_plus_ne_zero : χ.toLinear + α.1.toLinear ≠ 0
            have h_plus_ne_zero : χ.toLinear + α.1.toLinear ≠ 0 := h_plus_case

            by_cases h_minus_case : χ.toLinear - α.1.toLinear = 0
            · -- Case: χ - α = 0 (χ = α) - we're done here
              have h_chi_eq_alpha : χ.toLinear = α.1.toLinear := by
                simp only [sub_eq_zero] at h_minus_case; exact h_minus_case

              -- Prove the main goal directly when this special case holds
              apply LieSubmodule.mem_iSup_of_mem α
              simp only [sl2SubalgebraOfRoot_as_H_submodule]

              have hx_χ_alpha : x_χ ∈ genWeightSpace L α.1.toLinear := by
                rw [← h_chi_eq_alpha]; exact hx_χ

              have hx_χ_in_sl2 : x_χ ∈ sl2SubalgebraOfRoot α.2.2 := by
                have hx_χ_pos : x_χ ∈ rootSpace H α.1.toLinear := hx_χ_alpha
                obtain ⟨h, e, f, ht, heα, hfα⟩ :=
                  LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero α.2.2
                rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff α.2.2 ht heα hfα]
                have h_dim : Module.finrank K (rootSpace H α.1.toLinear) = 1 :=
                  LieAlgebra.IsKilling.finrank_rootSpace_eq_one α.1 α.2.2
                have he_ne_zero : e ≠ 0 := ht.e_ne_zero
                have he_subtype_ne_zero : (⟨e, heα⟩ : rootSpace H α.1.toLinear) ≠ 0 := by
                  rwa [ne_eq, LieSubmodule.mk_eq_zero]
                obtain ⟨c, hc⟩ := (finrank_eq_one_iff_of_nonzero'
                  ⟨e, heα⟩ he_subtype_ne_zero).mp h_dim ⟨x_χ, hx_χ_pos⟩
                have hc_proj : x_χ = c • e := by
                  have : x_χ = (⟨x_χ, hx_χ_pos⟩ : rootSpace H α.1.toLinear).val := rfl
                  rw [this, ← hc]; simp
                exact ⟨c, 0, 0, by simp [hc_proj]⟩

              have h_bracket_in_sl2 : ⁅x_χ, m_α⁆ ∈ sl2SubalgebraOfRoot α.2.2 := by
                have hm_α_in_sl2 : m_α ∈ sl2SubalgebraOfRoot α.2.2 := by
                  simp only [sl2SubalgebraOfRoot_as_H_submodule] at hm_α; exact hm_α
                apply LieSubalgebra.lie_mem; exact hx_χ_in_sl2; exact hm_α_in_sl2
              exact h_bracket_in_sl2
            · -- Case: χ - α ≠ 0, now we have h_minus_ne_zero : χ.toLinear - α.1.toLinear ≠ 0
              have h_minus_ne_zero : χ.toLinear - α.1.toLinear ≠ 0 := h_minus_case

              by_cases h_chi_case : χ.toLinear = 0
              · -- Case: χ = 0 (x_χ is in H) - we're done here
                have hx_χ_in_H : x_χ ∈ H.toLieSubmodule := by
                  rw [← rootSpace_zero_eq K L H]
                  convert hx_χ
                  ext h; simp only [Pi.zero_apply]
                  have h_apply : (χ.toLinear : H → K) h = 0 := by rw [h_chi_case]; rfl
                  exact h_apply.symm

                -- Prove the main goal directly when this special case holds
                apply LieSubmodule.mem_iSup_of_mem α
                simp only [sl2SubalgebraOfRoot_as_H_submodule]

                have hm_α_base : m_α ∈ sl2SubalgebraOfRoot α.2.2 := by
                  simp only [sl2SubalgebraOfRoot_as_H_submodule] at hm_α; exact hm_α
                exact sl2SubalgebraOfRoot_stable_under_H α.1 α.2.2 ⟨x_χ, hx_χ_in_H⟩ m_α hm_α_base
              · -- Case: χ ≠ 0, now we have h_chi_ne_zero : χ.toLinear ≠ 0
                have h_chi_ne_zero : χ.toLinear ≠ 0 := h_chi_case

                -- Now we're in the general case with χ + α ≠ 0, χ - α ≠ 0, and χ ≠ 0
                by_cases h_chi_in_q : χ.toLinear ∈ q
                · -- Case: χ ∈ q (general case with invariance)
                  sorry
                · -- Case: χ ∉ q (general case without invariance)
                  sorry

        | zero =>
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, lie_zero,
            SetLike.mem_coe, Submodule.zero_mem]
        | add m₁ m₂ _ _ ih₁ ih₂ =>
          -- m = m₁ + m₂ case
          rw [lie_add]
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
            at ih₁ ih₂ ⊢
          exact add_mem ih₁ ih₂
      | zero =>
        -- x = 0 case
        simp [zero_lie]
      | add x₁ x₂ _ _ ih₁ ih₂ =>
        -- x = x₁ + x₂ case
        rw [add_lie]
        simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
          at ih₁ ih₂ ⊢
        exact add_mem ih₁ ih₂
