import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]


/-- The sl2SubalgebraOfRoot is stable under H-action, so it can be viewed as an H-submodule -/
lemma sl2SubalgebraOfRoot_stable_under_H (α : Weight K H L) (hα : α.IsNonZero) :
    ∀ (h : H) (x : L), x ∈ sl2SubalgebraOfRoot hα → ⁅(h : L), x⁆ ∈ sl2SubalgebraOfRoot hα := by
  intro h x hx
  -- Since sl2SubalgebraOfRoot is generated by weight spaces,
  -- and H acts on weight spaces by scaling,
  -- the bracket ⁅h, x⁆ stays in the same weight spaces
  obtain ⟨h', e, f, ht, heα, hfα⟩ := LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero hα
  rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff hα ht heα hfα] at hx ⊢
  obtain ⟨c₁, c₂, c₃, hx_eq⟩ := hx
  -- x = c₁ • e + c₂ • f + c₃ • ⁅e, f⁆
  rw [hx_eq, lie_add, lie_add, lie_smul, lie_smul, lie_smul]
  -- Use the fact that H acts by scaling on weight spaces
  have he_weight : ⁅(h : L), e⁆ = α h • e := by
    exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace heα h
  have hf_weight : ⁅(h : L), f⁆ = (-α) h • f := by
    exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace hfα h
  have hef_weight : ⁅(h : L), ⁅e, f⁆⁆ = 0 • ⁅e, f⁆ := by
    -- ⁅e, f⁆ is the coroot, which lies in H
    -- Since H is abelian (Cartan subalgebras are abelian), ⁅h, ⁅e, f⁆⁆ = 0
    have h_coroot : ⁅e, f⁆ = (LieAlgebra.IsKilling.coroot α : L) := by
      have : ⁅e, f⁆ = h' := ht.lie_e_f
      rw [this]
      exact IsSl2Triple.h_eq_coroot hα ht heα hfα
    rw [h_coroot]
    -- coroot α ∈ H, and since H is abelian, ⁅h, coroot α⁆ = 0
    have : ⁅(h : L), (LieAlgebra.IsKilling.coroot α : L)⁆ = 0 := by
      -- The coroot has weight 0 (it lies in H, the zero weight space)
      -- By lie_eq_smul_of_mem_rootSpace: ⁅h, x⁆ = weight(x) h • x
      -- Since coroot α ∈ H has weight 0, we get ⁅h, coroot α⁆ = 0 • coroot α = 0
      have h_coroot_in_H : (LieAlgebra.IsKilling.coroot α : L) ∈ rootSpace H (0 : H → K) := by
        -- coroot α ∈ H and rootSpace H 0 = H.toLieSubmodule
        have h_coroot_mem_H : (LieAlgebra.IsKilling.coroot α : L) ∈ H := by
          exact (LieAlgebra.IsKilling.coroot α).property
        have h_eq : rootSpace H (0 : H → K) = H.toLieSubmodule := rootSpace_zero_eq K L H
        rw [h_eq]
        exact h_coroot_mem_H
      -- Apply lie_eq_smul_of_mem_rootSpace with weight 0
      have h_eq : ⁅(h : L), (LieAlgebra.IsKilling.coroot α : L)⁆ =
        (0 : H → K) h • (LieAlgebra.IsKilling.coroot α : L) := by
        exact LieAlgebra.IsKilling.lie_eq_smul_of_mem_rootSpace h_coroot_in_H h
      rw [h_eq]
      simp only [Pi.zero_apply, zero_smul]
    rw [this, zero_smul]
  rw [he_weight, hf_weight, hef_weight, smul_smul, smul_smul, zero_smul]
  simp only [Weight.coe_neg, Pi.neg_apply, smul_zero, add_zero]
  exact ⟨c₁ * α h, c₂ * (-α h), 0, by simp [mul_smul]⟩

/-- The sl2SubalgebraOfRoot can be viewed as an H-submodule -/
noncomputable def sl2SubalgebraOfRoot_as_H_submodule (α : Weight K H L) (hα : α.IsNonZero) :
    LieSubmodule K H L where
  __ := (sl2SubalgebraOfRoot hα).toLieSubmodule
  lie_mem := by
    intro h x hx
    exact sl2SubalgebraOfRoot_stable_under_H α hα h x hx

/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
    __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero},
      sl2SubalgebraOfRoot_as_H_submodule α.1 α.2.2
    lie_mem := by
      intro x m hm
      have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
        simp [LieModule.iSup_genWeightSpace_eq_top']
      induction hx using LieSubmodule.iSup_induction' with
      | mem χ x_χ hx_χ =>
        -- Apply inner induction on m ∈ ⨆ α, sl2SubmoduleOfRoot α.1 α.2.2
        induction hm using LieSubmodule.iSup_induction' with
        | mem α m_α hm_α =>
          -- Core case: x_χ ∈ genWeightSpace L χ, m_α ∈ sl2SubalgebraOfRoot_as_H_submodule α.1 α.2.2
          -- Since we now use sl2SubalgebraOfRoot_as_H_submodule,
          -- we have m_α ∈ sl2SubalgebraOfRoot α.2.2
          -- This greatly simplifies the proof

          -- Convert the membership to the underlying sl2SubalgebraOfRoot
          have hm_α_in_sl2 : m_α ∈ sl2SubalgebraOfRoot α.2.2 := by
            simp only [sl2SubalgebraOfRoot_as_H_submodule] at hm_α
            exact hm_α

          -- Case analysis based on invariance of q
          by_cases h_chi_in_q : χ.toLinear ∈ q
          · -- When χ.toLinear ∈ q, handle the χ + α component
            by_cases h_plus_zero : χ.toLinear + α.1.toLinear = 0
            · -- Case: χ.toLinear + α.1.toLinear = 0, so χ = -α
              -- When χ = -α, we have x_χ ∈ genWeightSpace L (-α) and m_α ∈ sl2SubalgebraOfRoot α
              -- We need to show ⁅x_χ, m_α⁆ ∈ H_α α by the coroot definition
              have h_chi_neg_alpha : χ.toLinear = -α.1.toLinear := by
                simp only [add_eq_zero_iff_eq_neg] at h_plus_zero
                exact h_plus_zero

              -- Apply the supremum membership for α
              apply LieSubmodule.mem_iSup_of_mem α
              simp only [sl2SubalgebraOfRoot_as_H_submodule]

              -- Step 1: Show that x_χ is part of the sl2 subalgebra
              -- Since χ = -α, we have x_χ ∈ genWeightSpace L (-α.1.toLinear)
              have hx_χ_neg_alpha : x_χ ∈ genWeightSpace L (-α.1.toLinear) := by
                have h_eq : χ.toLinear = -α.1.toLinear := h_chi_neg_alpha
                rw [← h_eq]
                exact hx_χ

              -- The sl2SubalgebraOfRoot α.2.2 contains the -α weight space
              have hx_χ_in_sl2 : x_χ ∈ sl2SubalgebraOfRoot α.2.2 := by
                -- Since x_χ ∈ genWeightSpace L (-α.1.toLinear), we can use the sl2 theory
                obtain ⟨h, e, f, ht, heα, hfα⟩ :=
                  LieAlgebra.IsKilling.exists_isSl2Triple_of_weight_isNonZero α.2.2
                have hx_χ_neg : x_χ ∈ rootSpace H (-α.1.toLinear) := hx_χ_neg_alpha
                -- Use mem_sl2SubalgebraOfRoot_iff: elements are linear combinations of e, f, ⁅e, f⁆
                rw [LieAlgebra.IsKilling.mem_sl2SubalgebraOfRoot_iff α.2.2 ht heα hfα]
                -- Since x_χ ∈ rootSpace H (-α.1.toLinear) and f ∈ rootSpace H (-α.1.toLinear),
                -- and root spaces are 1-dimensional, x_χ is a scalar multiple of f
                have h_dim : Module.finrank K (rootSpace H (-α.1.toLinear)) = 1 :=
                  LieAlgebra.IsKilling.finrank_rootSpace_eq_one (-α.1) (by simpa using α.2.2)
                -- For now, use the fact that both are in the same 1-dimensional space
                have : ∃ c : K, x_χ = c • f := by
                  sorry -- This follows from 1-dimensionality
                obtain ⟨c, hc⟩ := this
                -- Therefore x_χ ∈ sl2SubalgebraOfRoot as 0•e + c•f + 0•⁅e,f⁆
                exact ⟨0, c, 0, by simp [hc]⟩

              -- Step 2: Use the fact that sl2SubalgebraOfRoot is a Lie subalgebra
              -- Therefore ⁅x_χ, m_α⁆ ∈ sl2SubalgebraOfRoot α.2.2
              have h_bracket_in_sl2 : ⁅x_χ, m_α⁆ ∈ sl2SubalgebraOfRoot α.2.2 := by
                apply LieSubalgebra.lie_mem
                exact hx_χ_in_sl2
                exact hm_α_in_sl2

              -- Step 3: Now use the specific structure of the sl2 subalgebra
              -- The sl2SubalgebraOfRoot decomposes into weight spaces and coroot space
              -- Since x_χ ∈ genWeightSpace L (-α) and m_α has α components,
              -- their bracket must lie in the coroot space H_α by sl2 theory
              exact h_bracket_in_sl2

            · -- Case: χ.toLinear + α.1.toLinear ≠ 0
              sorry -- Handle this case later

          · -- Case: χ.toLinear ∉ q
            sorry -- Handle this case later

        | zero =>
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, lie_zero,
            SetLike.mem_coe, Submodule.zero_mem]
        | add m₁ m₂ _ _ ih₁ ih₂ =>
          -- m = m₁ + m₂ case
          rw [lie_add]
          simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
            at ih₁ ih₂ ⊢
          exact add_mem ih₁ ih₂
      | zero =>
        -- x = 0 case
        simp [zero_lie]
      | add x₁ x₂ _ _ ih₁ ih₂ =>
        -- x = x₁ + x₂ case
        rw [add_lie]
        simp only [LieSubmodule.iSup_toSubmodule, Submodule.carrier_eq_coe, SetLike.mem_coe]
          at ih₁ ih₂ ⊢
        exact add_mem ih₁ ih₂
