import Mathlib.Algebra.Lie.Sl2
import Mathlib.Algebra.Lie.Weights.Basic
import Mathlib.Algebra.Lie.Weights.Cartan
import Mathlib.Algebra.Lie.Weights.Killing
import Mathlib.Algebra.Lie.Weights.RootSystem
import Mathlib.Algebra.Module.Submodule.Invariant

variable {K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]
variable [LieAlgebra.IsKilling K L] [FiniteDimensional K L]

open LieAlgebra LieModule Module
open IsKilling (sl2SubalgebraOfRoot rootSystem)

variable {H : LieSubalgebra K L} [H.IsCartanSubalgebra] [IsTriangularizable K H L]

/-- Any invariant H* submodule defines a Lie ideal via its nonzero sl2 subalgebras.
    For an invariant submodule q ⊆ H*, define I_q = ⨆ α ∈ q ∩ Φ L(α)
    where L(α) is the sl2 subalgebra generated by the root α.
-/
noncomputable def invtSubmoduleToLieIdeal (q : Submodule K (Dual K H))
    (hq : ∀ i, q ∈ End.invtSubmodule ((rootSystem H).reflection i)) :
    LieIdeal K L where
  __ := ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubalgebraOfRoot α.2.2
  lie_mem := by
    intro x m hm
    -- Cartan decomposition: L = ⨆ χ : Weight K H L, genWeightSpace L χ
    have hx : x ∈ ⨆ χ : Weight K H L, genWeightSpace L χ := by
      simp [LieModule.iSup_genWeightSpace_eq_top']

    -- APPLY INDUCTION using LieSubmodule.iSup_induction' (following Killing.lean:129)
    induction hx using LieSubmodule.iSup_induction' with
    | mem χ x_χ hx_χ =>
      simp at hm
      have hm2 : m ∈ ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubalgebraOfRoot α.2.2 := by
        exact hm
      -- Apply nested induction on hm2: m ∈ ⨆ α, sl2SubalgebraOfRoot α.2.2
      -- Convert LieSubalgebra supremum to LieSubmodule supremum for induction
      have hm3 : m ∈ ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, (sl2SubalgebraOfRoot α.2.2).toSubmodule := by
        sorry
      apply Submodule.iSup_induction (fun α => (sl2SubalgebraOfRoot α.2.2).toSubmodule) (motive := fun y => ⁅x_χ, y⁆ ∈ ⨆ α : {α : Weight K H L // α.toLinear ∈ q ∧ α.IsNonZero}, sl2SubalgebraOfRoot α.2.2) hm3
      · -- mem case: y ∈ (sl2SubalgebraOfRoot α.2.2).toSubmodule for α with α.toLinear ∈ q ∧ α.IsNonZero
        intro α y hy
        sorry -- use RootPairing.root_mem_submodule_iff_of_add_mem_invtSubmodule
      · -- zero case: m = 0
        simp [zero_lie]
      · -- add case: m = y₁ + y₂
        intro y₁ y₂ ih₁ ih₂
        rw [lie_add]
        exact add_mem ih₁ ih₂
    | zero =>
      -- BASE CASE: x = 0
      simp [zero_lie]
    | add x₁ x₂ _ _ ih₁ ih₂ =>
      -- INDUCTIVE CASE: x = x₁ + x₂
      sorry -- rw [add_lie]; apply add_mem ih₁ ih₂
